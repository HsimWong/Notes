## 操作系統發展歷史
**推动操作系统发展的主要动力**
- 不断提高资源利用率
- 方便用户的使用
- 硬件不断更新
- 计算机体系结构的不断发展

**1. 无操作系统时代**
特点：使用真空管和插件板，人工操作
**用户独占全机器**、**CPU等待人工操作**

**单道批处理系统（第二代计算机（1955-1965））**
- 目标：减少CPU时间的浪费
- 作业：程序或者程序集
【作业控制语言JCL】：用来控制作业的执行，主要用于科学与工程计算。
- 缺点：CPU利用率低下，内存利用率低，有安全问题

**多道批处理系统（第三代）**
特点：增加了及地址寄存器和界限寄存器，提供多道程序设计
**缺點：**響應時間無法確定，不同的调度算法有不同的结果（交互式应用和批处理应用对响应时间有不同的需求
**分时系统**
每个用户有一个终端，n个用户同时申请任务，每个用户有$\frac{1}{n}$有效的处理器速度
**实时系统**
使用情况：对处理器操作或者数据流动有严格的时间要求
- 硬件实时系统：保证关键实时任务暗示开始或者按时完成
- 软件实时系统：关键实时任务的优先级高于其他任务的优先级。



## 操作系统基本特征
1. 并发
	- 并行：两个时间同一时刻发生
	- 并发：两个时间在同一个时间时间间隔发生
2. 共享(Sharing)
	互斥的共享方式
	同时访问方式
3. 虚拟
	虚拟机
	虚拟内存
4. 异步性（Asynchronism）
	内存中程序什么时候执行、暂停，需要多少时间完成都是不可知的

## 操作系统设计
设计和实现操作系统已经有一些事实证明可行的方法
1. OS内部方法
2. 一开始要定义目标
	1. 系统目标
	2. 用户目标
3. 受到硬件的影响很大

## 策略和机制分离的例子：计算机中CPU可能被一个任务长期霸占
- timer时常设置

## 操作系统结构
1. 整体式结构（早期使用）没怎么划分结构
- ms-dos:没有被仔细地划分模块
- 传统Unix：受到硬件的限制，而新版的unix可以更好地使用高级硬件
2. 层次式结构
- 优点：模块化
- 缺点：对层次的定义并且相对效率较差
*OS/2*
3. 微内核结构：将原本属于操作系统内核的功能放到内核的外部，使得内核成为一个微内核
- 操作系统的微内核之外的进程是服务器进程；而用户进程是客户进程。
- 微内核实现消息的传递
**易于维护、扩充**
4. 虚拟机结构
虚拟机监控器运行在硬件系统上，提供多道程序功能
虚拟机是硬件的完全拷贝
- 优点
	1. 提供安全层面
	2. 允许进行系统开发不必中断正常的操作系统


## 进程：正在进行的程序
程序：琴谱
进程：演奏的过程
运作结束，进程结束。程序是被动的实体，进程是活动的实体
进程可以被中断，但是需要被记录下来（期间IO有开销）
**可重入程序**：可以被多个程序同事调用的程序
它是纯代码的，自身不会改变。调用它的程序提供工作区，因此可充入地程序可以同事被几个程序调用。
- 在多到程序设计中，编译程序是可重入的程序。它可以同时编译若干个程序。
$\therefore$同一个程序在处理不同的数据是可以构成不同的进程

### 三状态运行模型
就绪、运行、等待

### 五状态进程模型
新状态、中止状态的加入

**问题：内存中所有进程都在等待状态怎么办**
在等待过程中挑选IO进程（victim）挪入硬盘（挂起）
这样一来，可以有新进程进入内存

##进程实体：一个进程由什么组成
**进程映像**程序、数据、堆栈、进程控制块：用于记录进程各种属性
**进程控制块的内容**
1. 进程标识
	1. 进程的ID
	2. 创建这个进程的进程ID
	3. 用户ID
2. 进程状态信息
	1. 用户可见寄存器
	2. 控制和状态寄存器
	3. 栈指针
3. 进程控制信息
	1. 调度和状态信息
	2. 数据结构
	3. 进程间通讯
	4. 进程特权
	5. 存储管理
	6. 资源的所有权和使用

## 进程控制块实现
为了实现进程模型，操作系统维护着一张表格（结构数组）成为进程表。
每一个进程占用一个表项，也就是每个进程的进程控制块PCB

## 调度队列
进程本身不排队，PCB排队
调度程序：
- 短期调度：把就绪队列中选择进程到CPU上边执行（执行频率高）
- 长期调度：挑选新进程进入内存。
	- IO为主
	- CPU为主
	执行频率低（几分钟一次），（有些系统根本不用这种调度），考物理限制和自然人用户的自我调整

## 进程创建
所有的子进程只能有一个父亲，进程与进程之间会形成一个进程树。
进程创建的原因：
1. 系统初始化
2. 执行了创建进程的系统调用
3. 用户请求创建一个新锦成
4. 一个批处理作业的初始化
*Unix进程创建*
- fork()创建新的子进程，子进程与父进程贡献地址空间
- exec()必须为了执行exec()的进程分配新的存储空间
*进程终止*
- 自己终止自己
	- 使用exit()系统调用
	- 父亲进城可以使用wait系统调用，从而得知终止进程的进程号
- 父进程终止子进程
	- 使用abort系统调用，传入子进程ID号码
- 操作系统终止进程
	- 引用不存在的内存，除以0
	- 级联终止：父进程终止，子进程也终止

**进程阻塞与唤醒**
- 进程阻塞：
	- 愿意：请求系统服务；启动某种操作；新数据尚未到达；没有新工作可做
	- 进程进入等待队列，进程状态变成等待
- 进程被唤醒
	- 原因：被阻塞的进程等待的时间到来，或者有其他的进程唤醒
	- 被唤醒的进程进入就绪状态

## 进程间通信IPC
**IPC通信机制**
- 管道：环形缓冲区，允许两个进程以*生产者*或*消费者*模式进行通信
- 共享内存
	- 进程间通信最快的形式
	- 多个进程贡献个虚拟内存中的一个内存块，进程读写这个内存块的指令
- 消息传递：是有类型的一段文本。通过发送和接受系统调用实现消息传递，每个进程都有一个相关的消息队列
只需要从本地的队列里送入或

**管道**：用于连接一个*读进程*和*写进程*
- 普通管道只能用于父子进程之间
	- 父进程创建管道与子进程通信
	- 子进程从父进程集成管道
	- 父子都会关闭不需要的管道端口
**消息传递**
**直接通信**：

## 线程的有点
- 响应度高
- 资源共享
- 通信简单
- 经济：创建进程所需内存昂贵，线程相对会小一点
- 多处理器结构应用

## 线程的分类
### 用户级的线程
- 缺点
	- 线程阻塞导致整个进程阻塞（多线程对于内核来说是一个进程）
	- 无法利用多处理器奇数
- 有点
	- 切换简单

### 内核级线程（对于所有线程来说）
- 缺点：
	- 线程切换需要增加内核处理，增加了切换的模式

### 混合方法
- 线程在用户控件创建
- 大部分线程调度和同步是在用户空间中实现
- Solaris
**线程库**

# 进程的同步
## 协作进程
- 进程之间的关系
	- 独立的
		- 一个进程不影响其他进程，不被其他进程影响
	- 协作的
		进程之间相互影响：信息共享、加快计算（分配计算）、模块化（）
- 两个独立进程之间有关系：
	- 抢占

## 进程同步问题的提出
**竞争条件**：两个以上的进程共享数据，而最终的执行结果是根据执行的次序决定的
**控制对共享资源的访问**：
为了避免竞争条件，
**临界资源**：共享的数据
**临界区**：访问这些临界资源的代码
**互斥**如果有进程在临界区中执行，其他进程都不能在临界区中执行，这样可以避免竞争
**有空让进**、**有限等待**、不可以对进程的相对执行速度进行任何假设！！！

## 解决临界区互斥的问题
### 软件解决方案
### 硬件解决方案
- 屏蔽中断：进入临界去之前中断，离开之后断开中断
	- 现代操作系统是中断驱动的，没有了中断，操作系统就失去了系统控制能力
	- 只有在一个CPU的时候有效

- 原子地修改检查

**忙等待**：持续地检测一个变量知道它具有某一个特定值（浪费CPU时间）
优先翻转

## 信号量方法：
- 两个或者多个进程可以用信号的方法进行写作
- 进程可以在任何地方停下来，以等待收到特定的信号
- 信号的实现是一种称为**信号量**的特殊变量

信号量S就是一个特殊变量、包含一个整数值
wait()用来接收信号
signal()发送信号
*信号量*分类
- 技术信号量
- 二院信号量

## 如何用信号量实现互斥


# 时间片轮转算法
- 抢占式调度算法
	- 始终每隔一段时间产生一个中断
	- 运行状态的进程进入就绪状态
	- 用FCCFS算法从就绪队列中选择一个

# 优先权调度算法
- 非抢占式优先权调度算法
- 

# 多级反馈队列调度
- 可抢占式算法
	- 有多个队列优先级从高到低

# 死锁
- 死锁的基本概念
	-  由于要使用排他的资源，因此会产生自锁
	- 资源的分类
		- 可剥夺的资源
			- 剥夺后原有战友的进程
		- 不可不多的资源


- 产生死锁的四个必要条件
- 死锁的预防
- 死锁的避免
